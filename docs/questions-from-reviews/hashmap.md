---
title: Хеш-мапы
sidebar_position: 1
description: Вопросы по хеш-мапам в Golang
---

## Что такое мапа?

Мапа в Go - это тип данных, который предназначен для хранения пар "ключ-значение". Это структура данных, также известная как хэш-таблица, словарь или ассоциативный массив. Мапа позволяет получить значение по ключу. Ключами в мапе могут быть любые сравниваемые типы — все простые скалярные типы, каналы, массивы.

```go title="main.go"
package main

import "fmt"

func main() {
    m := make(map[string]int)
    m["apple"] = 1
    m["banana"] = 2
    fmt.Println(m)
}
```

## Что произойдет при конкурентной записи в мапу?

Мапы в Go не являются потокобезопасными. Это означает, что если вы попытаетесь записать данные в мапу из нескольких горутин одновременно, это может привести к состоянию гонки. Состояние гонки - это ситуация, когда результат выполнения программы зависит от того, в каком порядке выполняются операции. Если вам нужно работать с мапой из нескольких горутин, вы должны использовать механизмы синхронизации, такие как sync.Mutex или sync.RWMutex, чтобы гарантировать, что в любой момент времени только одна горутина может изменять мапу. Вот пример использования sync.Mutex для безопасной записи в мапу из нескольких горутин:

```go title="main.go"
package main

import (
    "fmt"
    "sync"
)

func main() {
    var wg sync.WaitGroup
    var mu sync.Mutex
    m := make(map[int]int)

    for i := 0; i < 10; i++ {
        wg.Add(1)
        go func(i int) {
            defer wg.Done()
            mu.Lock()
            m[i] = i * 2
            mu.Unlock()
        }(i)
    }

    wg.Wait()
    fmt.Println(m)
}
```

## Как устроена мапа под капотом?

Мапа в Go - это структура данных, которая хранит пары "ключ-значение". Внутри мапы ключи и значения хранятся в выделенном участке памяти, последовательно. Для получения адресов ячеек конкретных ключей и значений используется хэширующая функция. 

Вот некоторые детали о том, как устроена мапа в Go:

- [Мапа разбивается на бакеты для более эффективного поиска](https://www.youtube.com/watch?v=P_SXTUiA-9Y).
- [Хэш-функция используется для равномерного распределения ключей по бакетам](https://www.youtube.com/watch?v=P_SXTUiA-9Y).
- [При переполнении бакета происходит рост мапы](https://www.youtube.com/watch?v=P_SXTUiA-9Y).
- [Эвакуация данных происходит при заполнении мапы](https://www.youtube.com/watch?v=P_SXTUiA-9Y).
- [Порядок обхода мапы является случайным](https://www.youtube.com/watch?v=P_SXTUiA-9Y).

## Какие ключи могут быть у мапы?

Ключами в мапе могут быть любые сравниваемые типы — все простые скалярные типы, каналы, массивы. Несравниваемые типы — срезы, мапы, функциии. Ключи и значения мапы будут храниться в выделенном участке памяти, последовательно.

## Какая сложность работы с мапой?

Операции вставки, удаления и поиска в мапе в Go обычно имеют сложность O(1), то есть они выполняются за постоянное время. Это достигается за счет использования хэш-таблицы внутри мапы. Однако в худшем случае, когда все ключи попадают в один и тот же бакет, эти операции могут иметь сложность O(n), где n - количество элементов в мапе

## Можно ли взять адрес элемента мапы и почему?

Нет, нельзя взять адрес элемента мапы в Go. Это связано с тем, как устроена мапа внутри. Мапа разбита на бакеты, и при росте мапы элементы могут переходить из одного бакета в другой. Это означает, что адрес элемента в памяти может меняться, и поэтому Go не позволяет взять адрес элемента мапы. Если вы попытаетесь это сделать, компилятор выдаст ошибку.

## Как работает эвакуация данных?

Эвакуация данных в мапе Go происходит при переполнении мапы. Когда количество элементов в мапе достигает определенного порога, мапа “растет” - создается новая, большая мапа, и все элементы из старой мапы копируются в новую. Этот процесс называется "эвакуацией". Важно отметить, что в Go рост мапы происходит асинхронно. Это означает, что во время роста мапы могут возникать ситуации, когда при попытке доступа к данным часть бакетов уже переехала в новую мапу, а часть еще нет. Благодаря этому не происходит просадок во время роста большой мапы.

## Как разрешаются коллизии в мапе?

В мапе Go коллизии разрешаются с помощью бакетов. Каждый бакет может содержать до восьми элементов. Если все ячейки в бакете заняты, то происходит переполнение и мапа “растет” - создается новая, большая мапа, и все элементы из старой мапы копируются в новую. Этот процесс называется "эвакуацией". При этом, благодаря использованию хэш-функции, ключи равномерно распределяются по бакетам. Это позволяет минимизировать количество коллизий и обеспечивает быстрый доступ к данным.

## В функции make для мапы мы указываем число. Что оно дает?

Число, указываемое в функции make для мапы в Go, определяет начальную вместимость мапы. Это число элементов, которые мапа сможет хранить без необходимости расширения. Если вы заранее знаете, сколько элементов будет в мапе, вы можете использовать это число при создании мапы, чтобы уменьшить количество операций реаллокации памяти, что может улучшить производительность. Вот пример создания мапы с начальной вместимостью 10:

```go title="main.go"
m := make(map[string]int, 10)
```

## Стало слишком много коллизий в мапе, как решить проблему?

Если в мапе Go стало слишком много коллизий, вы можете использовать следующие подходы для решения проблемы:

Изменить размер мапы: Если мапа слишком мала, она может быстро заполняться, что приводит к большому количеству коллизий. В этом случае вы можете увеличить размер мапы, чтобы уменьшить вероятность коллизий.

Использовать метод раздельного связывания: Это метод, при котором внутри хеш-таблицы хранится массив фиксированного размера, элементы которого - связанные списки. По хешу ключа определяется элемент массива (bucket - корзину) и потом смотрится в списке, нет ли такого элемента и действуется соответствующее (добавляется/удаляется/модифицируется).

## Чем мапа отличается от sync.Map?

**sync.Map** и обычная мапа в Go имеют различия в использовании и производительности

1. **Потокобезопасность**: Обычная мапа в Go не является потокобезопасной, что означает, что одновременная запись в мапу из нескольких горутин может привести к состоянию гонки. В то время как **`sync.Map`** разработана для использования в многопоточных ситуациях и обеспечивает потокобезопасность.
2. **Производительность** **`sync.Map`** обычно близка по скорости к обычной мапе с **`sync.RWMutex`**, но может быть лучше в случае чтения. Когда происходит чтение и обновление, **`sync.Map`** будет иметь элементы и в чтении, и в “грязном” состоянии.
3. **Использование** **`sync.Map`** - это структура с методами, предоставляющими обычные операции с мапой. Вы не можете использовать синтаксис **`a_map["key"]`** с **`sync.Map`**, вместо этого нужно использовать методы, такие как **`Load`**, **`Store`** и **`Delete`**.
4. **Структура** **`sync.Map`** - это сложная структура, обычно состоящая из двух мап - одной для чтения и одной для новых элементов.

Важно отметить, что **`sync.Map`** следует использовать только в тех случаях, когда большинство операций с мапой - это чтение, и когда ключи мапы меняются динамически2.