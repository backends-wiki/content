---
title: Defer
sidebar_position: 6
description: Вопросы по работе с defer в Golang
---

## Что такое defer, как работет, зачем нужен?

defer - это ключевое слово в языке программирования Go, которое используется для определения функции, которая должна быть выполнена после возвращения текущей функции, но до возвращения вызвавшей ее функции. Это позволяет очистить ресурсы или выполнить другие задачи, которые необходимо выполнить после завершения основной работы функции.

Когда вызывается функция с ключевым словом defer, она не выполняется немедленно. Вместо этого она добавляется в список функций, которые будут выполняться в обратном порядке после возвращения текущей функции. Это означает, что последняя функция, вызванная с ключевым словом defer, будет выполнена первой после возврата текущей функции.

Ключевое слово defer полезно для обеспечения правильной очистки ресурсов, например, для закрытия файлов или сетевых соединений. Его также можно использовать для упрощения обработки ошибок, позволяя функции возвращать значение ошибки, а затем обрабатывать эту ошибку в одном месте после возврата функции.

Источники: 
 - [Habr](https://habr.com/ru/articles/492948/)
 - [DigitalOcean](https://www.digitalocean.com/community/tutorials/understanding-defer-in-go-ru)

## Задача #1

```go title="main.go"
package main

import (
	"fmt"
)

func main() {
	tmp := 101
	fmt.Println(tmp)
	defer func() {
		fmt.Println(tmp)
	}()
	tmp = 202
	return
}
```

Этот код использует концепцию "замыкания". Замыкание - это функция, которая имеет доступ к переменным из своего внешнего контекста. 
В данном случае, анонимная функция, которую откладывается с помощью defer, имеет доступ к переменной tmp из внешнего контекста.

Когда вы вызываете `defer func() { fmt.Println(tmp) }()`, функция "захватывает" текущее значение tmp на момент вызова. 

Однако в этом случае tmp является ссылкой на переменную во внешнем контексте. Это значит, что если tmp изменяется после вызова defer, то измененное значение будет использоваться в отложенной функции.

tmp сначала устанавливается в 101, затем выводится, затем откладывается функция, которая выводит tmp, и наконец tmp изменяется на 202.
Когда функция main завершается, отложенная функция вызывается и выводит текущее значение tmp, которое теперь равно 202.
В результате, вывод программы будет 101 и 202.

## Задача #2

```go title="main.go"
package main

import (
    "fmt"
)

func main() {
	tmp := 101
	fmt.Println(tmp)
	defer func(tmpx int) {
		fmt.Println(tmpx)
	}(tmp)
	tmp = 202
	return
}
```

В этом примере мы передаем tmp в отложенную функцию как аргумент. Это означает, что значение tmp будет скопировано в отложенную функцию, а не ссылаться на переменную во внешнем контексте.

В результате, вывод программы будет 101 и 101.



