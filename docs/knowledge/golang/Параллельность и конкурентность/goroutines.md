---
title: Горутины
sidebar_position: 12
description: Вопросы по горутинам.
---

## Что такое горутина?

Горутина - это функция, которая может выполняться параллельно с другими функциями в одном адресном пространстве. Горутины - это особенность языка программирования Go, который позволяет создавать легковесные потоки исполнения. Горутины могут обмениваться данными с помощью каналов, которые являются потокобезопасными структурами данных.

Источники:
- [Habr](https://habr.com/ru/companies/otus/articles/527748/)
- [Habr](https://habr.com/ru/articles/141853/)
- [Metanit](https://metanit.com/go/tutorial/7.1.php)

## Чем горутина отличается от треда?

Горутина отличается от треда несколькими способами:

- Горутина имеет меньший размер стека, чем тред, и может динамически его расширять при необходимости.
- Горутина не связана с конкретным системным потоком, а управляется планировщиком Go, который может переключать горутины между разными потоками.
- Горутина может быть запущена с помощью ключевого слова go, в то время как тред требует вызова специальной функции или библиотеки.
- Горутина может общаться с другими горутинами через каналы, которые обеспечивают синхронизацию и безопасность данных. Треды же обычно используют разделяемую память и механизмы блокировки.

Источники: 
- [Habr](https://habr.com/ru/articles/141853/)
- [Medium](https://medium.com/nuances-of-programming/%D0%BA%D0%BE%D0%BD%D0%BA%D1%83%D1%80%D0%B5%D0%BD%D1%82%D0%BD%D0%BE%D1%81%D1%82%D1%8C-%D0%B8-%D0%BF%D0%B0%D1%80%D0%B0%D0%BB%D0%BB%D0%B5%D0%BB%D0%B8%D0%B7%D0%BC-%D0%B2-golang-go-%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D0%B4%D1%83%D1%80%D1%8B-82bae0f92e81)

## В чем преимущества горутин над тредами?

Некоторые преимущества горутин над тредами включают:

- Более высокую производительность и меньшее потребление ресурсов, так как горутины занимают меньше памяти и переключаются быстрее.
- Более простую и элегантную модель конкурентности, основанную на каналах, которые избегают проблем с блокировками и гонками данных.

## Что есть в Golang для многопоточности?

В Golang для многопоточности есть горутины и каналы. Горутины - это легковесные потоки, которые можно запускать с помощью ключевого слова go. Каналы - это потокобезопасные структуры данных, которые позволяют обмениваться данными между горутинами. GOMAXPROCS - это параметр, который определяет, сколько ядер ЦП используется для одновременного выполнения горутин.

## Как можно остановить горутину?
Остановить горутину можно с помощью контекста, канала или таймаута. Контекст позволяет передавать сигналы о завершении работы между горутинами. Канал позволяет отправлять и получать значения между горутинами, в том числе команды на остановку. Таймаут позволяет ограничить время работы горутины и прервать ее, если она не успела выполниться. 

Вот некоторые примеры использования этих механизмов:

С помощью контекста:
```go
package main

import (
	"context"
	"fmt"
	"time"
)

func main() {
	// создаем контекст с отменой
	ctx, cancel := context.WithCancel(context.Background())
	// запускаем горутину с этим контекстом
	go worker(ctx)
	// ждем 3 секунды
	time.Sleep(3 * time.Second)
	// отменяем контекст
	cancel()
	// ждем еще 2 секунды
	time.Sleep(2 * time.Second)
}

func worker(ctx context.Context) {
	for {
		select {
		case <-ctx.Done():
			// контекст отменен, выходим из горутины
			fmt.Println("worker stopped")
			return
		default:
			// продолжаем работать
			fmt.Println("worker working")
			time.Sleep(time.Second)
		}
	}
}
```

С помощью канала:
```go
package main

import (
	"fmt"
	"time"
)

func main() {
	// создаем канал для передачи сигнала остановки
	stop := make(chan bool)
	// запускаем горутину с этим каналом
	go worker(stop)
	// ждем 3 секунды
	time.Sleep(3 * time.Second)
	// отправляем сигнал остановки в канал
	stop <- true
	// ждем еще 2 секунды
	time.Sleep(2 * time.Second)
}

func worker(stop chan bool) {
	for {
		select {
		case <-stop:
			// получили сигнал остановки, выходим из горутины
			fmt.Println("worker stopped")
			return
		default:
			// продолжаем работать
			fmt.Println("worker working")
			time.Sleep(time.Second)
		}
	}
}
```

С помощью таймаута:
```go
package main

import (
	"fmt"
	"time"
)

func main() {
	// создаем канал для получения результата работы
	result := make(chan string)
	// запускаем горутину с этим каналом
	go worker(result)
	// устанавливаем таймаут в 3 секунды
	timeout := time.After(3 * time.Second)
	select {
	case res := <-result:
		// получили результат работы до таймаута
		fmt.Println("worker finished:", res)
	case <-timeout:
		// время вышло, прерываем горутину
		fmt.Println("worker timeout")
	}
}

func worker(result chan string) {
	// имитируем долгую работу
	time.Sleep(5 * time.Second)
	// отправляем результат в канал
	result <- "success"
}
```

## Когда возникает утечка горутины?

Утечка горутины возникает, когда горутина продолжает существовать и занимать ресурсы, хотя ее работа уже завершена или не требуется. Это может привести к замедлению работы системы или даже сбою. 

Некоторые причины утечки горутин могут быть:

- Неправильное использование каналов, например, отправка или получение из закрытого или неполного канала, или блокировка канала без возможности выхода.
- Неэффективное управление контекстами, например, отсутствие отмены или таймаута для контекстов, передаваемых в горутины.
- Неожиданные ошибки или паники, которые прерывают работу горутины, не освобождая ресурсы.
- Неоптимальный дизайн программы, например, создание избыточного количества горутин или недостаточный контроль над их жизненным циклом.