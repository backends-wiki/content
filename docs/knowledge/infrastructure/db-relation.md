---
title: Базы данных (реляционные)
sidebar_position: 2
description: Вопросы по реляционным базам данных
---

## Что такое индексы, для чего используются?

Индексы в реляционных базах данных используются для ускорения процесса поиска данных. Они работают по принципу индексов в книге: вместо того чтобы просматривать каждую страницу книги (или каждую строку в таблице данных), вы можете просто посмотреть в индекс, найти нужное значение и сразу перейти к нужной странице (или строке данных).

Индексы могут быть особенно полезны при выполнении операций сравнения, таких как операторы `WHERE`, `ORDER BY` и `JOIN` в SQL. Однако стоит помнить, что индексы также занимают место в памяти и могут замедлить операции вставки, обновления и удаления, поскольку индекс также нужно обновлять при каждом изменении данных.

## Какие примеры индексов знаешь, на каких структурах данных они основаны? (PostgreSQL)

PostgreSQL поддерживает несколько типов индексов:

1. B-Tree: Это наиболее часто используемый тип индекса в PostgreSQL. Он хорошо работает для операций равенства и диапазонов.
2. Hash: Этот тип индекса эффективен для операций равенства. Однако, он не поддерживает диапазонные запросы.
3. GiST (Generalized Search Tree): Этот тип индекса поддерживает балансировку дерева и может быть использован для различных типов данных.
4. GIN (Generalized Inverted Index): Этот тип индекса эффективен для данных, которые содержат несколько значений в одной колонке (например, массивы).

B-Tree (сбалансированное дерево) - это структура данных, которая поддерживает логарифмическое время для операций поиска, вставки и удаления. В B-Tree каждый узел имеет множество ключей и ссылок на дочерние узлы. Ключи делят связи на диапазоны, так что B-Tree может быстро определить, в каком диапазоне находится искомый ключ, и перейти к соответствующему дочернему узлу. Этот процесс повторяется, пока не будет найден искомый ключ или не будет достигнут листовой узел.

## Какие есть уровни изоляций транзакций. Зачем они нужны? Как отличаются?

Уровни изоляции транзакций определяют, как транзакции взаимодействуют друг с другом. Они нужны для обеспечения консистентности данных при одновременном выполнении нескольких транзакций. В SQL стандарте определены следующие уровни изоляции:

1. `READ UNCOMMITTED`: На этом уровне транзакции могут видеть незавершенные изменения (так называемые "грязные" данные) от других транзакций. Это самый низкий уровень изоляции, и он может привести к множеству проблем, таких как проблемы с чтением "грязных" данных.
2. `READ COMMITTED`: На этом уровне транзакция может видеть только те данные, которые были зафиксированы до начала транзакции. Это предотвращает чтение "грязных" данных, но все еще может привести к некоторым проблемам, таким как неповторяемое чтение.
3. `REPEATABLE READ`: На этом уровне транзакция видит только те данные, которые были зафиксированы до начала транзакции, и эти данные не изменяются в течение всей транзакции. Это предотвращает неповторяемое чтение, но может привести к фантомным чтениям.
4. `SERIALIZABLE`: Это самый высокий уровень изоляции. Он предотвращает все виды конфликтов чтения и записи, обеспечивая, что транзакции выполняются в строгом последовательном порядке, как если бы они выполнялись одна за другой.

Уровни изоляции транзакций служат для балансировки между производительностью (более высокие уровни изоляции могут замедлить выполнение транзакций) и консистентностью данных (более низкие уровни изоляции могут привести к проблемам с данными).

## Зачем нужна денормализация БД?

Денормализация базы данных - это процесс, при котором мы уменьшаем нормализацию (сокращаем количество таблиц и/или объединяем данные в одной таблице), чтобы улучшить производительность.

Вот некоторые причины, по которым может потребоваться денормализация:
1. **Улучшение производительности запросов**: Денормализация может уменьшить количество соединений между таблицами при выполнении запросов, что может улучшить производительность.
2. **Упрощение запросов**: Денормализация может сделать запросы более простыми и понятными, поскольку данные могут быть организованы таким образом, чтобы лучше соответствовать запросам, которые вы делаете.
3. **Увеличение скорости чтения**: Денормализация может увеличить скорость чтения за счет уменьшения количества операций соединения.


Однако стоит помнить, что денормализация может привести к увеличению объема хранимых данных и сложности обслуживания, поскольку изменения данных теперь нужно будет вносить в несколько мест. Поэтому решение о денормализации должно быть обоснованным и взвешенным.

## Что такое JOIN?

`JOIN` - это операция в SQL, которая используется для объединения строк из двух или более таблиц на основе общего поля между ними. 

Существуют различные типы операций `JOIN`:
1. `INNER JOIN`: Возвращает строки, когда есть совпадение в обеих таблицах.
2. `LEFT JOIN` (или `LEFT OUTER JOIN`): Возвращает все строки из левой таблицы и совпадающие строки из правой таблицы. Если нет совпадения, результатом является NULL с правой стороны.
3. `RIGHT JOIN` (или `RIGHT OUTER JOIN`): Возвращает все строки из правой таблицы и совпадающие строки из левой таблицы. Если нет совпадения, результатом является NULL с левой стороны.
4. `FULL JOIN` (или `FULL OUTER JOIN`): Возвращает строки, когда есть совпадение в одной из таблиц. То есть, если в левой таблице есть совпадение, оно возвращается, и если в правой таблице есть совпадение, оно также возвращается.

Операция `JOIN` позволяет извлекать данные из нескольких таблиц как один набор данных, что может быть очень полезно при работе с нормализованными базами данных, где данные распределены по нескольким таблицам.

## Что можем сделать если запрос жирный и много JOINов?

Если запрос содержит много операций `JOIN` и становится "жирным" (т.е. медленным или ресурсоемким), есть несколько способов оптимизации:
1. **Индексация**: Убедитесь, что поля, используемые в операциях `JOIN`, индексированы. Индексы могут значительно ускорить операции `JOIN`.
2. **Уменьшение количества JOIN'ов**: Попробуйте уменьшить количество операций `JOIN`, если это возможно. Это может включать в себя денормализацию данных или изменение структуры запроса.
3. **Использование подзапросов**: В некоторых случаях подзапросы могут быть более эффективными, чем сложные операции `JOIN`.
4. **Оптимизация запроса**: Пересмотрите свой запрос и убедитесь, что он написан максимально эффективно. Это может включать в себя использование `EXPLAIN PLAN` (или аналогичного инструмента в вашей СУБД) для понимания, как СУБД выполняет ваш запрос, и определения возможных узких мест.
5. **Использование представлений**: Если один и тот же сложный запрос выполняется многократно, может быть полезно создать представление (view), которое хранит результат этого запроса.
6. **Вертикальное разделение**: Если таблицы, используемые в `JOIN`, очень большие, может быть полезно применить вертикальное разделение, т.е. разделить таблицы на более мелкие по набору колонок. 

Помните, что оптимальный подход зависит от конкретной ситуации и может потребовать тестирования различных стратегий.

## Расскажи подробнее про триггеры (ППО). Какие есть плюсы-минусы?

Триггеры в базах данных - это специальные процедуры, которые автоматически запускаются (или "срабатывают") при определенных событиях, таких как вставка, обновление или удаление записей в таблице.

**Плюсы триггеров:**

1. **Автоматизация**: Триггеры позволяют автоматизировать рутинные операции, которые должны происходить при определенных изменениях данных.
2. **Целостность данных**: Триггеры могут быть использованы для поддержания целостности данных, автоматически обновляя данные в одной таблице при изменении данных в другой.
3. **Аудит**: Триггеры могут быть использованы для отслеживания изменений в данных, автоматически записывая информацию об изменениях в журнал аудита.

**Минусы триггеров:**

1. **Производительность**: Триггеры могут замедлить операции с базой данных, поскольку каждое изменение данных может вызывать выполнение дополнительного кода.
2. **Сложность отладки**: Триггеры могут сделать систему сложнее для понимания и отладки, поскольку они работают "за кулисами" и могут вызывать неожиданные изменения данных.
3. **Порядок выполнения**: Если есть несколько триггеров, которые срабатывают при одном и том же событии, порядок их выполнения может быть неочевидным и привести к неожиданным результатам.

Важно помнить, что триггеры - это мощный инструмент, но они должны использоваться с осторожностью. Они лучше всего подходят для обработки сложных требований к целостности данных, которые не могут быть легко реализованы с помощью стандартных ограничений SQL.



## Почему плохо использовать много индексов?

Использование индексов в базе данных ускоряет операции чтения, но есть и обратная сторона медали. Вот несколько причин, по которым использование большого количества индексов может быть нежелательным:

1. **Замедление операций записи**: Каждый раз, когда вы вставляете, обновляете или удаляете данные, все индексы, связанные с этими данными, также должны быть обновлены. Это может значительно замедлить операции записи.
2. **Увеличение использования дискового пространства**: Индексы занимают дисковое пространство. Чем больше индексов у вас есть, тем больше дискового пространства они занимают.
3. **Увеличение сложности обслуживания**: Индексы требуют обслуживания (например, перестройки или переиндексации), что может увеличить сложность обслуживания базы данных.
4. **Неправильное использование индексов**: СУБД может не всегда эффективно использовать индексы, особенно если есть много индексов на выбор. Это может привести к неоптимальным планам выполнения запросов.

Важно помнить, что индексы - это инструмент, который должен использоваться обдуманно. Необходимо регулярно анализировать и оптимизировать индексы для обеспечения наилучшей производительности.

## Слышал про нормализацию? Расскажи в двух словах. 

Нормализация в контексте баз данных - это процесс организации данных в таблицах для минимизации дублирования и обеспечения целостности данных. Это достигается путем разделения данных на несколько связанных таблиц и установления отношений между ними. Нормализация помогает улучшить производительность, упрощает обслуживание и обновление данных, и предотвращает возникновение аномалий данных.

## Приходилось сталкиваться с оконными функциями? Расскажи про них

Оконные функции в SQL позволяют выполнять вычисления относительно набора строк, связанных с текущей строкой. Они называются "оконными", потому что они работают с "окном" строк в результате запроса.

Оконные функции могут быть очень полезны для выполнения сложных аналитических и статистических вычислений, таких как ранжирование, вычисление скользящих средних, суммирование и т.д.

Пример оконной функции в SQL:

```sql
SELECT name, salary, AVG(salary) OVER (PARTITION BY department) as avg_salary
FROM employees;
```

В этом примере `AVG(salary) OVER (PARTITION BY department)` - это оконная функция. Она вычисляет среднюю зарплату для каждого отдела (т.е. "окна" данных, определенного `PARTITION BY department`).

Еще пример:

```sql
SELECT name, salary, RANK() OVER (ORDER BY salary DESC) as salary_rank
FROM employees;
```

Оконные функции не изменяют набор результатов запроса. Вместо этого они добавляют новые столбцы, которые могут содержать информацию, вычисленную на основе окна строк.

## Что такое ACID?

ACID - это акроним, который описывает четыре основных свойства, которые гарантируют надежные обработку транзакций и обновления в базе данных:

1. **Atomicity (Атомарность)**: Это свойство гарантирует, что транзакция рассматривается как единое целое. Это означает, что либо все операции транзакции выполняются успешно, либо, если какая-либо операция в транзакции не удается, то все операции откатываются, и состояние базы данных остается неизменным.
2. **Consistency (Согласованность)**: Это свойство гарантирует, что транзакция приводит базу данных из одного согласованного состояния в другое. Правила целостности данных должны быть соблюдены.
3. **Isolation (Изолированность)**: Это свойство гарантирует, что параллельное выполнение транзакций оставляет базу данных в таком же состоянии, как если бы транзакции выполнялись последовательно.
4. **Durability (Долговечность)**: Это свойство гарантирует, что после успешного завершения транзакции любые изменения, внесенные в базу данных, сохраняются и остаются постоянными, даже в случае сбоя системы.

Эти свойства являются важными для обеспечения надежности и корректности работы системы баз данных.

## Как реализована буква D из ACID в PostgreSQL?

Буква "D" в ACID означает Durability (Долговечность). В контексте баз данных это свойство гарантирует, что после успешного завершения транзакции любые изменения, внесенные в базу данных, сохраняются и остаются постоянными, даже в случае сбоя системы.

В PostgreSQL долговечность обеспечивается с помощью механизма Write-Ahead Logging (WAL). Вот как это работает:
1. Когда транзакция выполняется, все изменения данных сначала записываются в журнал предварительной записи (WAL). Это включает в себя как данные, так и информацию о транзакции.
2. Эти записи WAL затем физически записываются на диск. Это гарантирует, что даже если система внезапно упадет, информация о транзакции и изменениях данных не будет потеряна.
3. Только после того, как запись WAL была успешно записана на диск, транзакция считается завершенной, и изменения данных могут быть применены к основной базе данных.
4. Если система восстанавливается после сбоя, PostgreSQL может использовать журнал WAL, чтобы узнать, какие транзакции были завершены и какие изменения данных должны быть применены.

Таким образом, PostgreSQL обеспечивает долговечность данных, гарантируя, что завершенные транзакции будут сохранены, даже если произойдет сбой системы.

## Что такое репликация? Что происходит при репликации, что передается на реплики?

Репликация в контексте баз данных - это процесс копирования данных из одной базы данных (обычно называемой "мастер" или "первичной") в одну или несколько других баз данных (обычно называемых "репликами" или "вторичными").

Цель репликации - увеличить доступность и надежность данных. Если основная база данных становится недоступной или теряет данные, вы можете переключиться на одну из реплик без потери данных. Репликация также может улучшить производительность, позволяя распределить нагрузку чтения между несколькими серверами.

Во время репликации обычно передаются следующие данные:

1. **Транзакции**: Все изменения данных, которые произошли в основной базе данных, передаются на реплики. Это включает в себя операции вставки, обновления и удаления.
2. **Состояние базы данных**: В некоторых системах репликации, таких как снимки или полная репликация, также может передаваться текущее состояние базы данных.
3. **Метаданные**: Информация о структуре базы данных и ее объектах (таблицы, индексы, ограничения и т.д.) также может передаваться в процессе репликации.

Существуют различные стратегии репликации (например, асинхронная vs синхронная, однонаправленная vs двунаправленная), и выбор подходящей стратегии зависит от конкретных требований к доступности, надежности и производительности.

## Что такое TOASTING?

TOAST (The Oversized-Attribute Storage Technique) в PostgreSQL - это механизм, который позволяет хранить большие значения данных, которые не умещаются в обычной странице базы данных (обычно размером 8 КБ).

Когда строка данных превышает определенный размер (обычно около 2 КБ), PostgreSQL автоматически использует TOAST для сжатия и/или разделения данных на несколько кусков, которые затем хранятся в отдельной TOAST-таблице. Каждая основная таблица в PostgreSQL имеет связанную TOAST-таблицу для хранения таких больших значений.

Когда вы запрашиваете данные, PostgreSQL автоматически собирает и распаковывает данные из TOAST-таблицы, делая этот процесс прозрачным для пользователя.

TOAST позволяет PostgreSQL эффективно работать с большими значениями данных, минимизируя использование дискового пространства и улучшая производительность.


## Что такое MVCC?

MVCC (Multi-Version Concurrency Control) - это метод управления параллельным доступом к базе данных, который позволяет одновременно выполнять транзакции чтения и записи без блокировки данных.

В MVCC каждая транзакция видит базу данных в определенном состоянии, которое соответствует моменту времени, когда транзакция начала выполнение. Это достигается путем хранения нескольких версий каждой строки данных, каждая из которых соответствует состоянию строки в определенный момент времени.

Когда транзакция выполняет операцию чтения, она видит последнюю версию строки, которая была актуальной на момент начала транзакции. Это позволяет избежать блокировок чтения и записи, поскольку транзакции могут одновременно читать данные, даже если другие транзакции изменяют эти данные.

MVCC широко используется в современных СУБД, таких как PostgreSQL, Oracle и других, и является важным механизмом для обеспечения высокой производительности и надежности при работе с базами данных.

## Что такое хранимая процедура? Зачем они нужны?

Хранимая процедура (или хранимая функция) - это набор инструкций SQL, который сохраняется в базе данных и может быть вызван из других программ или запросов.
Хранимые процедуры могут быть написаны на различных языках программирования, таких как SQL, PL/pgSQL, PL/Python, PL/Perl и других, в зависимости от СУБД.
Хранимые процедуры полезны по нескольким причинам:

1. **Уменьшение сетевого трафика**: Поскольку хранимые процедуры выполняются на сервере базы данных, они могут уменьшить количество данных, которые должны быть переданы между сервером базы данных и клиентским приложением.
2. **Улучшение производительности**: Хранимые процедуры могут быть оптимизированы для выполнения на сервере базы данных, что может улучшить производительность.
3. **Сокрытие сложности**: Хранимые процедуры могут использоваться для сокрытия сложности запросов и бизнес-логики от клиентских приложений.
4. **Повторное использование кода**: Хранимые процедуры могут быть повторно использованы в различных частях приложения или различных приложениях.
5. **Улучшение безопасности**: Хранимые процедуры могут использоваться для ограничения доступа к данным и обеспечения безопасности.

Хранимые процедуры - это мощный инструмент, который может быть использован для улучшения производительности, безопасности и обслуживания базы данных.

## Сталкивался с дэдлоками? Что это такое и когда происходит? Допустим у тебя update батча, то есть в транзакции апдейтишь 1000 строк и у тебя множество параллельных транзакций и может быть пересечение данных, как не словить дэдлок?

Дэдлок в базах данных - это ситуация, когда две или более транзакций взаимно блокируют друг друга, каждая ожидая, пока другая освободит ресурс. Это может произойти, когда транзакции конкурируют за доступ к одним и тем же строкам данных.

Вот несколько способов избежать дедлоков:

1. **Упорядочивание доступа к ресурсам**: Если все транзакции всегда запрашивают доступ к ресурсам в одном и том же порядке, дедлоки не могут произойти.
2. **Избегание долгих транзакций**: Чем дольше транзакция держит блокировку, тем больше вероятность дедлока. По возможности старайтесь делать транзакции как можно короче.
3. **Использование тайм-аутов**: Можно установить тайм-аут на блокировку ресурса. Если транзакция не может получить блокировку в течение определенного времени, она откатывается, освобождая свои ресурсы и предотвращая дедлок.
4. **Использование механизмов обнаружения дедлоков**: Большинство СУБД, включая PostgreSQL, имеют встроенные механизмы обнаружения дедлоков. Когда обнаруживается дедлок, одна из транзакций автоматически откатывается, освобождая свои блокировки и разрешая другим транзакциям продолжить работу.

В случае с обновлением батча, если есть вероятность пересечения данных между транзакциями, одним из подходов может быть упорядочивание обновлений по какому-то критерию (например, по ID строки), чтобы уменьшить вероятность дедлока.

## Каким образом выявили узкое место в SQL? (ППО)

В SQL есть команда `EXPLAIN PLAN`, которая показывает, как СУБД планирует выполнить запрос. Это может помочь выявить, какие части запроса занимают больше всего времени, и выявить возможные проблемы, такие как отсутствие индексов или неэффективные операции соединения.

Помните, что оптимизация SQL - это итеративный процесс, который может потребовать многократного тестирования и настройки.

## У нас есть запрос с JOIN, но не по id и не по PRIMARY KEY. Есть индекс, но в запросе он не используется. Почему?

Система управления базами данных (СУБД) определяет, какие индексы использовать при выполнении запроса, на основе статистической информации о данных. Если СУБД решает, что использование индекса не будет эффективным, она может выбрать другой план выполнения запроса.

Вот несколько возможных причин, почему индекс может не использоваться в запросе с JOIN:

1. **Низкая выборочность**: Если индексированное поле содержит много дубликатов, индекс может быть неэффективным для ускорения запроса. Это обычно происходит, когда поле имеет низкую "выборочность" (т.е., большое количество строк имеют одно и то же значение).
2. **Неправильный тип соединения**: Некоторые типы соединений (например, OUTER JOIN) могут препятствовать использованию индексов.
3. **Неправильный порядок столбцов в индексе**: Если индекс состоит из нескольких столбцов, порядок этих столбцов в индексе имеет значение. Если столбец, используемый в JOIN, не является первым в индексе, индекс может не использоваться.
4. **Неправильное использование функций или операторов**: Если в условии JOIN используются функции или операторы, которые не могут использовать индекс, индекс может не использоваться.

Для определения, почему индекс не используется, вы можете использовать команду `EXPLAIN PLAN` (или аналогичный инструмент в вашей СУБД), чтобы увидеть, как СУБД планирует выполнить запрос.

## В качестве идентификатора что лучше bigint или uuid? Когда uuid может нам помочь?

Выбор между `bigint` и `uuid` для идентификатора зависит от конкретных требований вашего приложения.

**`bigint`** обычно используется, когда вам нужен простой, упорядоченный идентификатор. Он занимает меньше места (8 байтов) и обычно быстрее для операций сравнения и сортировки. Однако, если вам нужно объединять данные из нескольких баз данных или таблиц, могут возникнуть проблемы с конфликтами идентификаторов.

**`uuid`** представляет собой универсальный уникальный идентификатор, который генерируется таким образом, что вероятность его дублирования крайне мала. Это делает `uuid` идеальным для ситуаций, когда вам нужно гарантировать уникальность идентификатора во всем мире, например, при репликации данных между несколькими базами данных или при создании распределенных систем. Однако `uuid` занимает больше места (16 байтов) и может быть медленнее для операций сравнения и сортировки.

В общем, если вам нужна глобальная уникальность идентификатора, `uuid` может быть хорошим выбором. Если же вам нужен простой, эффективный идентификатор и вы уверены, что конфликты идентификаторов не будут проблемой, `bigint` может быть более подходящим.

## Что такое партиционирование(Секционирование)? Когда его стоит применять?

Партиционирование в базах данных — это процесс разделения больших таблиц на более мелкие фрагменты, называемые разделами или партициями, с целью повышения производительности, улучшения управляемости и обеспечения более эффективного использования ресурсов хранения. Партиционирование может применяться как для горизонтального, так и для вертикального разделения данных. Горизонтальное партиционирование относится к разделению данных на основе строк или диапазонов значений ключа, тогда как вертикальное партиционирование относится к разделению данных на основе столбцов.

### Основные принципы партиционирования:
1. **Разделение данных**: Таблица разделяется на отдельные сегменты данных, которые могут быть обрабатываемыми независимо друг от друга. Каждый сегмент содержит свой поднабор строк из исходной таблицы.
2. **Ключ разделения**: Для определения, в какую партицию должна попасть каждая строка, используется ключ разделения. Это может быть определенный столбец или набор столбцов, по которым данные распределяются между различными партициями.
3. **Прозрачный доступ**: Хотя данные разделены на различные фрагменты, для пользователя или приложения это должно быть незаметно. Пользователь должен иметь возможность выполнять запросы к таблице, как если бы она была одним целым.
4. **Управление и обслуживание**: Партиционирование упрощает управление большими объемами данных, поскольку позволяет выполнить административные задачи, такие как добавление и удаление данных, в отдельных частях таблицы, а не на всей таблице целиком.
5. **Улучшение производительности**: Партиционирование может повысить производительность запросов, поскольку запросы могут быть направлены только к определенным разделам, что уменьшает объем данных, обрабатываемых при выполнении запроса.

### Партиционирование стоит применить в следующих случаях:
1. **Работа с большими объемами данных**: Когда объем данных в таблице становится очень большим, партиционирование может помочь управлять этими данными, улучшая производительность запросов и упрощая администрирование.
2. **Регулярное удаление старых данных**: Если ваше приложение регулярно удаляет старые данные, партиционирование позволяет удалить эти данные из отдельных партиций, что может быть более эффективным, чем удаление данных из целой таблицы.
3. **Повышение производительности запросов**: Партиционирование может улучшить производительность запросов, направляя запросы только к определенным партициям, уменьшая объем данных, обрабатываемых при выполнении запроса.
4. **Управление обновлением и вставками данных**: Если ваше приложение часто выполняет операции вставки и обновления данных, партиционирование может помочь улучшить производительность этих операций, разделяя данные на более мелкие фрагменты.
5. **Горизонтальное масштабирование**: Партиционирование может быть использовано в качестве стратегии горизонтального масштабирования, позволяя распределить данные по разным узлам или серверам для балансировки нагрузки и увеличения производительности.

